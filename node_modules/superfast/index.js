'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var lodash = require('lodash');
var events = require('events');
var path = require('path');
var path__default = _interopDefault(path);
var PouchDB = _interopDefault(require('pouchdb'));
var promisify = _interopDefault(require('es6-promisify'));
var _mkdirp = _interopDefault(require('mkdirp'));
var fs = _interopDefault(require('fs-promise'));
var _resolve = _interopDefault(require('resolve'));
var chokidar = _interopDefault(require('chokidar'));
var del = _interopDefault(require('del'));
var tar = _interopDefault(require('tar-stream'));
var zlib = require('zlib');
var _cpr = _interopDefault(require('cpr'));
var latest = _interopDefault(require('latest-versions'));
var child_process = require('child_process');
var CleanCSS = _interopDefault(require('clean-css'));
var browserify = _interopDefault(require('browserify'));
var UglifyJS = _interopDefault(require('uglify-js'));
var through = _interopDefault(require('through2'));

var babelHelpers = {};
babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
};

babelHelpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

babelHelpers.createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

babelHelpers.inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

babelHelpers.possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

babelHelpers.slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

babelHelpers;

var ignore = require("ignore");

var ignore_keys = ["_patterns", "_rules", "_ignoreFiles"];

ignore.merge = function () {
	for (var _len = arguments.length, eyes = Array(_len), _key = 0; _key < _len; _key++) {
		eyes[_key] = arguments[_key];
	}

	var ign = ignore();
	eyes = eyes.filter(function (i) {
		return i instanceof ignore.Ignore;
	});

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = eyes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var i = _step.value;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = ignore_keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var k = _step2.value;

					ign[k] = ign[k].concat(i[k]);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			lodash.assign(ign.options, i.options);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return ign;
};

ignore.Ignore.prototype.clone = function () {
	return ignore.merge(this);
};

ignore.Ignore.prototype.merge = function () {
	for (var _len2 = arguments.length, i = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		i[_key2] = arguments[_key2];
	}

	return ignore.merge.apply(null, [this].concat(i));
};

function getIgnoreFile(p) {
	return fs.readFile(p, {
		encoding: "utf-8"
	}).catch(function () {
		return "";
	}).then(function (src) {
		return ignore().addPattern(src.split(/\r?\n/g));
	});
}

function getIgnoreFileSync(p) {
	var src = undefined;
	try {
		src = fs.readFileSync(p, { encoding: "utf-8" });
	} catch (e) {
		src = "";
	}
	return ignore().addPattern(src.split(/\r?\n/g));
}

// gets all files in a folder that aren't ignored
function traverse(root, igfile) {
	var dive = function dive(dir) {
		return fs.readdir(path__default.resolve(root, dir)).then(function (files) {
			var p = [];

			// grab ignore for just this folder
			if (lodash.includes(files, igfile)) {
				files = lodash.without(files, igfile);
				p.push(getIgnoreFile(path__default.resolve(root, dir, igfile)));
			}

			// descend into each file/folder
			p.push(Promise.all(files.map(function (f) {
				var rel = path__default.join(dir, f);
				return fs.stat(path__default.resolve(root, rel)).then(function (stat) {
					if (stat.isDirectory()) {
						return dive(rel).then(function (files) {
							return files.map(function (_f) {
								return path__default.join(f, _f);
							});
						});
					}

					if (stat.isFile()) return f;
				});
			})));

			// process files with ignore
			return Promise.all(p).then(function (r) {
				var i = undefined,
				    files = undefined;
				if (r.length === 1) files = r[0];else {
					;

					var _r = babelHelpers.slicedToArray(r, 2);

					i = _r[0];
					files = _r[1];
				}files = lodash.flatten(files).filter(Boolean);
				if (i) files = i.filter(files);
				return files;
			});
		});
	};

	return dive(".");
}

// tests a file within root to see if it should be ignored
function test(file, root, igfile) {
	file = path__default.relative(root, path__default.resolve(root, file));

	// outside of this folder is undefined behavior
	if (/^\.\.\//.test(file)) return;

	// root is always good
	file = file.split("/");
	if (!file.length) return true;

	var localname = [];

	// run through directories testing ignores
	var next = function next() {
		// no more file parts? this file is OK
		if (!file.length) return true;

		// shift file name parts
		localname.unshift(file.pop());
		var rel = localname.join("/");

		// test each local name to each ignore file
		var i = getIgnoreFileSync(path__default.join(root, file.join("/"), igfile));
		if (i && !i._filter(rel)) return false;

		return next();
	};

	return next();
}

// for methods that we don't know if they are callback or promise async
function confusedAsync(fn, ctx, args) {
	if (fn.length > args.length) {
		return new Promise(function (resolve, reject) {
			fn.apply(ctx, args.concat(function (err, r) {
				if (err) reject(err);else resolve(r);
			}));
		});
	} else {
		return Promise.resolve(fn.apply(ctx, args));
	}
}

var Source = function () {
	function Source(compiler, fpath) {
		babelHelpers.classCallCheck(this, Source);

		this.compiler = compiler;
		this.path = fpath;
		this.type = null;
		this.targets = [];
		this.removed = false;
	}

	babelHelpers.createClass(Source, [{
		key: "setType",
		value: function setType(type) {
			this.type = type;
			return this;
		}
	}, {
		key: "target",
		value: function target(v) {
			if (!lodash.isArray(v)) v = v != null ? [v] : [];
			this.targets = v;
			return this;
		}
	}, {
		key: "isTarget",
		value: function isTarget(t) {
			return lodash.includes(this.targets, t);
		}
	}]);
	return Source;
}();

var File = function (_Source) {
	babelHelpers.inherits(File, _Source);

	function File() {
		babelHelpers.classCallCheck(this, File);
		return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(File).apply(this, arguments));
	}

	babelHelpers.createClass(File, [{
		key: "transform",
		value: function transform(options) {
			var _this2 = this;

			options = options || {};
			var rev = undefined;

			return Promise.all([this.fetch(), fs.stat(this.fullpath).catch(function (e) {
				if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
			})]).then(function (r) {
				var _r = babelHelpers.slicedToArray(r, 2);

				var doc = _r[0];
				var stat = _r[1];

				// no need to transform a missing file

				_this2.removed = !stat;
				if (_this2.removed) return;

				// no need to transform a perfectly good cached version
				if (!options.force && doc && stat.mtime <= doc.timestamp) {
					rev = doc._rev;
					_this2.target(doc.targets);
					_this2.setType(doc.type);
					return;
				}

				// get source and transform
				return fs.readFile(_this2.fullpath, {
					encoding: "utf-8"
				}).then(function (src) {
					var fns = _this2.compiler.transforms.slice(0);
					var next = function next(s) {
						if (typeof s === "string") src = s;
						if (_this2.removed) return Promise.resolve();
						if (!fns.length) return Promise.resolve(src);
						return confusedAsync(fns.shift(), _this2.compiler, [_this2, src]).then(next);
					};

					return next();
				});
			}).then(function (src) {
				if (_this2.removed) return _this2.delete(rev);
				if (typeof src === "string") return _this2.save(src);
			});
		}
	}, {
		key: "getSource",
		value: function getSource() {
			return this.compiler.database.getAttachment(this.path, "data").then(function (src) {
				return src.toString("utf-8");
			});
		}
	}, {
		key: "fetch",
		value: function fetch() {
			return this.compiler.database.get(this.path).catch(function (e) {
				if (e.status !== 404) throw e;
			}).then(function (doc) {
				if (!doc) return;
				doc.timestamp = new Date(doc.timestamp);
				return doc;
			});
		}
	}, {
		key: "save",
		value: function save(src) {
			var _this3 = this;

			var doc = {
				_id: this.path,
				_attachments: {
					"data": {
						"content_type": "text/plain",
						"data": new Buffer(src, "utf-8")
					}
				},
				timestamp: new Date(),
				type: this.type,
				targets: this.targets
			};

			return this._rev().then(function (rev) {
				doc._rev = rev;
				return _this3.compiler.database.put(doc);
			});
		}
	}, {
		key: "delete",
		value: function _delete(rev) {
			var _this4 = this;

			var p = rev ? Promise.resolve(rev) : this._rev();

			return p.then(function (rev) {
				return _this4.compiler.database.remove(_this4.path, rev).catch(function (e) {
					if (e.status !== 404) throw e;
				});
			});
		}
	}, {
		key: "_rev",
		value: function _rev() {
			// using allDocs() over a normal get() because we only need
			// the latest revision, not the whole document
			return this.compiler.database.allDocs({
				key: this.path,
				limit: 1
			}).then(function (res) {
				if (res && res.rows.length) {
					return res.rows[0].value.rev;
				}
			});
		}
	}, {
		key: "fullpath",
		get: function get() {
			return this.compiler.resolve(this.path);
		}
	}]);
	return File;
}(Source);

var Module = function (_Source2) {
	babelHelpers.inherits(Module, _Source2);

	function Module() {
		babelHelpers.classCallCheck(this, Module);
		return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Module).apply(this, arguments));
	}

	return Module;
}(Source);

function javascript(file) {
	if (path.extname(file.path) !== ".js") return;
	file.setType("script");
}

function css(file) {
	if (path.extname(file.path) !== ".css") return;
	file.setType("style");
}

function target(file) {
	var parts = file.path.split("/");
	var targets = [];

	if (lodash.includes(parts, "client") || /^client\.|\.client\./i.test(lodash.last(parts))) {
		targets.push("client");
	}

	if (lodash.includes(parts, "server") || /^server\.|\.server\./i.test(lodash.last(parts))) {
		targets.push("server");
	}

	if (!targets.length) targets = ["client", "server"];
	file.target(targets);
}

var transforms = [javascript, css, target];

function styles(files) {
	var _this = this;

	var buf = new Buffer(0);
	files = files.filter(function (f) {
		return f.isTarget("client") && f.type === "style";
	});

	var next = function next() {
		if (!files.length) return Promise.resolve();
		var f = files.shift();

		return f.getSource().then(function (src) {
			buf = Buffer.concat([buf, new Buffer("/* " + f.path + " */\n"), new Buffer(src + "\n")]);
		}).then(next);
	};

	return next().then(function () {
		var res = buf.toString("utf-8");

		if (_this.production) {
			res = new CleanCSS({
				keepSpecialComments: false
			}).minify(res).styles;
		}

		return {
			path: (_this.production ? ".superfast/" : "") + "client.css",
			source: res
		};
	});
}

function cacheify (b) {
	var cache = b._options.cache;
	var pkgcache = b._options.packageCache;

	if (cache) {
		b.on('reset', collect);
		collect();
	}

	function collect() {
		b.pipeline.get('deps').push(through.obj(function (row, enc, next) {
			var file = row.expose ? b._expose[row.id] : row.file;
			cache[file] = {
				source: row.source,
				deps: lodash.assign({}, row.deps)
			};
			this.push(row);
			next();
		}));
	}

	b.on('package', function (pkg) {
		var file = path.join(pkg.__dirname, 'package.json');
		if (pkgcache) pkgcache[file] = pkg;
	});

	b.invalidate = function (id) {
		if (cache) delete cache[id];
		if (pkgcache) delete pkgcache[id];
	};

	return b;
}

function isClientScript(f) {
	return f.isTarget("client") && f.type === "script";
}

function client (files, options) {
	var _this = this;

	var opts = lodash.assign({
		basedir: this.cwd
	}, options);

	if (!this._browserify) {
		this._browserify = { cache: {}, packageCache: {} };
		this.on("transform", this._browserify.onTransform = function (t) {
			if (_this._browserify) t.forEach(function (f) {
				delete _this._browserify.cache[f.path];
				delete _this._browserify.packageCache[f.path];
			});
		});
	}

	if (!this.production) {
		opts.cache = this._browserify.cache;
		opts.packageCache = this._browserify.packageCache;
		opts.fullPaths = true;
		opts.debug = true;
	}

	var b = browserify(opts);
	if (opts.cache) b = cacheify(b);

	this.requires.forEach(function (f) {
		if (isClientScript(f)) b.require({
			entry: true,
			file: f.path,
			id: f.path
		});
	});

	// add every file
	return Promise.all(files.filter(isClientScript).map(function (f) {
		return f.getSource().then(function (src) {
			b.require({
				source: src,
				entry: true,
				file: f.fullpath,
				id: f.fullpath
			});
		});
	})).then(function () {
		return promisify(b.bundle.bind(b))();
	}).then(function (src) {
		src = src.toString("utf-8");

		if (_this.production) {
			src = UglifyJS.minify(src, {
				fromString: true
			}).code;
		}

		return {
			path: (_this.production ? ".superfast/" : "") + "client.js",
			source: src
		};
	});
}

function printRequire(n) {
	return "require(" + JSON.stringify(n) + ");\n";
}

function isServerScript(f) {
	return f.isTarget("server") && f.type === "script";
}

function serverScripts(files) {
	var _this = this;

	var str = "";

	this.requires.forEach(function (f) {
		if (isServerScript(f)) str += printRequire(f.path);
	});

	var p = files.filter(isServerScript).map(function (f) {
		var p = path__default.normalize(f.path);
		str += printRequire((!/^\.{0,2}\//.test(p) ? "../" : "") + p);

		if (_this.production) return f.getSource().then(function (s) {
			return { path: p, source: s };
		});
	});

	return Promise.all(p).then(function (res) {
		res.push({
			path: (_this.production ? ".superfast/" : "") + "server.js",
			source: str
		});

		return res;
	});
}

function unspecified (files) {
	if (!this.production) return;

	return Promise.all(files.filter(function (f) {
		return !f.type || !f.targets.length;
	}).map(function (f) {
		return f.getSource().then(function (src) {
			return {
				path: f.path,
				source: src
			};
		});
	}));
}

var outputs = { unspecified: unspecified, styles: styles, client: client, server: serverScripts };

var Runner = function (_EventEmitter) {
	babelHelpers.inherits(Runner, _EventEmitter);

	function Runner(compiler, options) {
		babelHelpers.classCallCheck(this, Runner);

		var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Runner).call(this));

		options = options || {};

		// internal state
		_this.s = {
			// compiler instance
			compiler: compiler,
			// whether or not the server is ready
			ready: false,
			// is this the firstrun
			firstRun: true
		};

		// user options
		_this.options = options;

		// attach to compiler
		_this._attach();
		return _this;
	}

	babelHelpers.createClass(Runner, [{
		key: "_attach",
		value: function _attach() {
			var _this2 = this;

			var tserver = false;
			var tclient = false;

			this.compiler.on("transform", function (t) {
				t.forEach(function (f) {
					if (f.isTarget("client")) tclient = true;
					if (f.isTarget("server")) tserver = true;
				});
			});

			this.compiler.on("compile", function () {
				if (_this2.running) {
					if (tserver) _this2.restart();else if (tclient) _this2.process.send({ type: "client_update" });
				}
				tserver = tclient = false;
			});
		}
	}, {
		key: "start",
		value: function start(cb) {
			var _this3 = this;

			if (this.running) {
				if (typeof cb === "function") cb();
				return;
			}

			var _onExit = undefined,
			    onMessage = undefined,
			    onParentExit = undefined,
			    p = undefined;

			var args = [];
			args = args.concat(this.options._);

			var server_start = path__default.resolve(this.compiler.buildDir, "server.js");
			p = this.s.process = child_process.fork(server_start, args, {
				silent: true,
				cwd: this.compiler.cwd
			});

			p.stdout.pipe(process.stdout);
			p.stderr.pipe(process.stderr);

			// ensure child dies when the parent process does
			process.on("exit", onParentExit = function onParentExit() {
				return _this3.kill();
			});

			p.on("exit", _onExit = function onExit(code) {
				process.removeListener("exit", onParentExit);
				p.removeListener("exit", _onExit);
				p.removeListener("message", onMessage);

				if (_this3.s.process === p) delete _this3.s.process;
				_this3.s.ready = false;
				_this3.emit("exit", code);
				_this3.s.firstRun = false;

				// restart if it exited with an error
				if (code && _this3.ready) _this3.restart();
			});

			p.on("message", onMessage = function onMessage(msg) {
				if ((typeof msg === "undefined" ? "undefined" : babelHelpers.typeof(msg)) !== "object" || msg == null) return;

				switch (msg.type) {
					case "ping":
						{
							p.send({ type: "pong", value: msg.value });
							break;
						}

					case "ready":
						{
							if (_this3.s.ready) break;
							_this3.s.ready = true;
							_this3.emit("ready", msg.address);
							if (typeof cb === "function") cb();
							break;
						}
				}
			});

			p.on("error", function (e) {
				return _this3.emit("error", e);
			});
			this.emit("start", p);
		}
	}, {
		key: "kill",
		value: function kill(cb) {
			if (typeof cb !== "function") cb = function cb() {};
			if (this.s.process) {
				this.emit("kill");
				var p = this.s.process;
				this.once("exit", function () {
					return process.nextTick(cb);
				});
				p.kill();
			} else {
				cb();
			}
		}
	}, {
		key: "restart",
		value: function restart(cb) {
			var _this4 = this;

			this.emit("restart");
			this.kill(function () {
				return _this4.start(cb);
			});
		}
	}, {
		key: "compiler",
		get: function get() {
			return this.s.compiler;
		}
	}, {
		key: "ready",
		get: function get() {
			return this.s.ready;
		}
	}, {
		key: "firstRun",
		get: function get() {
			return this.s.firstRun;
		}
	}, {
		key: "running",
		get: function get() {
			return Boolean(this.s.process);
		}
	}, {
		key: "process",
		get: function get() {
			return this.s.process;
		}
	}]);
	return Runner;
}(events.EventEmitter);

function read(file, reviver) {
	return fs.readFile(file, { encoding: "utf-8" }).catch(function (e) {
		if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
	}).then(function (src) {
		return src ? JSON.parse(src, reviver) : {};
	});
}

function write(file, data, replacer, space) {
	var src = JSON.stringify(data, replacer, space);
	return fs.writeFile(file, src);
}

var nonalphanumeric = /[^a-z0-9]+/ig;
var trimdash = /^-|-$/g;

function slug (str) {
	return str.trim().toLowerCase().replace(nonalphanumeric, "-").replace(trimdash, "");
}

function sortFiles(files) {
	return files.map(function (f) {
		return f.split("/");
	}).sort(function (a, b) {
		// main files are always last
		var amain = lodash.last(a).substr(0, 5) === "main.";
		var bmain = lodash.last(b).substr(0, 5) === "main.";
		if (amain && !bmain) return 1;else if (!amain && bmain) return -1;

		// lib folders are always first
		var alib = lodash.includes(a, "lib");
		var blib = lodash.includes(b, "lib");
		if (alib && !blib) return -1;else if (!alib && blib) return 1;

		// deeper paths before short paths
		if (a.length > b.length) return -1;else if (b.length > a.length) return 1;

		// normal alphabetical
		return a.join("/").localeCompare(b.join("/"));
	}).map(function (f) {
		return f.join("/");
	});
}

var mkdirp = promisify(_mkdirp);
var resolveModule = promisify(_resolve);
var cpr = promisify(_cpr);

var Compiler = function (_EventEmitter) {
	babelHelpers.inherits(Compiler, _EventEmitter);

	function Compiler(dir, options) {
		babelHelpers.classCallCheck(this, Compiler);

		var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Compiler).call(this));

		options = lodash.assign({}, Compiler.defaults, options);

		// internal state
		_this.s = {
			// the root folder to build from
			cwd: path__default.resolve(dir || "."),
			// whether or not in production build mode
			production: Boolean(options.production),
			// paths to ignore while compiling
			ignore: ignore().addPattern(options.ignore),
			// names of plugins that have loaded
			plugins: [],
			// holds file objects
			files: new Map(),
			// additional NPM modules to require
			requires: new Map(),
			// will hold a database for caching files
			database: null,
			// holds all the transform functions
			transforms: [],
			// holds all the output functions
			outputs: {},
			// dir where build files go
			build_dir: options.buildDir || ".superfast",
			// whether or not setup has run
			setup: false
		};

		// user options
		_this.options = options;

		// add default transforms
		_this.transform(transforms);

		//  add default outputs
		_this.output(outputs);
		return _this;
	}

	babelHelpers.createClass(Compiler, [{
		key: "resolve",

		// returns a path resolved to the compiler's cwd
		value: function resolve() {
			var args = [this.cwd].concat(lodash.toArray(arguments));
			return path__default.resolve.apply(null, args);
		}

		// looks through the directory to find all matching files
		// sorts the files based on Meteor's sort rules

	}, {
		key: "scan",
		value: function scan(dir) {
			var _this2 = this;

			return traverse(this.resolve(dir || "."), ".sfignore").then(function (files) {
				return sortFiles(_this2.ignore.filter(files));
			});
		}
	}, {
		key: "test",
		value: function test$$(file) {
			file = path__default.relative(this.cwd, path__default.resolve(this.cwd, file));
			return test(file, this.cwd, ".sfignore") && this.ignore._filter(file);
		}

		// extra files in the pipeline, added by plugins

	}, {
		key: "include",
		value: function include(f, type, targets) {
			f = path__default.relative(this.cwd, path__default.resolve(this.cwd, f));
			var file = this._add_file(f);
			file.setType(type);
			file.target(targets);
			file.include = true;
			return file;
		}
	}, {
		key: "require",
		value: function require(f, type, targets) {
			var file = this.s.requires.get(f);
			if (!file) {
				file = new Module(this, f);
				this.s.requires.set(f, file);
			}
			file.setType(type);
			file.target(targets);
			return file;
		}
	}, {
		key: "transform",
		value: function transform() {
			var _this3 = this;

			for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
				fns[_key] = arguments[_key];
			}

			fns.forEach(function (t) {
				if (Array.isArray(t)) {
					return _this3.transform.apply(_this3, t);
				}

				if (typeof t !== "function") {
					throw new Error("Expecting function for transform.");
				}

				_this3.s.transforms.push(t);
			});

			return this;
		}
	}, {
		key: "output",
		value: function output(name, fn) {
			var _this4 = this;

			if ((typeof name === "undefined" ? "undefined" : babelHelpers.typeof(name)) === "object" && name != null) {
				lodash.map(name, function (f, n) {
					return _this4.output(n, f);
				});
				return this;
			}

			if (typeof name !== "string" || !name) {
				throw new Error("Expecting non-empty string for output name.");
			}

			if (typeof fn !== "function") {
				throw new Error("Expecting function for output.");
			}

			this.s.outputs[name] = fn;
			return this;
		}
	}, {
		key: "depend",
		value: function depend(plugins) {
			var _this5 = this;

			plugins = lodash.flatten([].concat(plugins)).filter(Boolean);

			var next = function next() {
				if (!plugins.length) return Promise.resolve();
				var name = plugins.shift();

				if (!name || lodash.includes(_this5.s.plugins, name)) return next();

				return resolveModule(name, {
					basedir: _this5.cwd,
					packageFilter: function packageFilter(pkg, file) {
						pkg.__filename = file;
						pkg.__dirname = path__default.dirname(file);

						if (pkg.superfast && typeof pkg.superfast === "string") {
							pkg._originalMain = pkg.main;
							pkg.main = pkg.superfast;
						}

						return pkg;
					}
				}).catch(function (e) {
					if (!/cannot find module/i.test(e.toString())) throw e;
				}).then(function (r) {
					if (!lodash.isArray(r) || !r.length) return;
					_this5.s.plugins.push(name);

					var _r = babelHelpers.slicedToArray(r, 2);

					var file = _r[0];
					var pkg = _r[1];

					if (!pkg.superfast) return;

					return Promise.resolve().then(function () {
						var plugin = require(file);
						if (typeof plugin === "function") {
							return confusedAsync(plugin, null, [_this5]);
						}
					}).then(function () {
						_this5.emit("plugin", name);
					});
				}).then(next);
			};

			return next();
		}

		// creates the cwd if it doesn't exist and copies in example

	}, {
		key: "setup",
		value: function setup() {
			var _this6 = this;

			return Promise.resolve().then(function () {
				if (_this6.hasSetup) return;
				_this6.s.setup = true;

				return _this6._step0().then(function () {
					return _this6._step1();
				}).then(function () {
					return _this6.emit("setup");
				});
			}).catch(function (e) {
				_this6.s.setup = false;
				throw e;
			});
		}
	}, {
		key: "compile",
		value: function compile(options, handle) {
			var _this7 = this;

			if (!this.hasSetup) {
				throw new Error("Hasn't setup yet.");
			}

			return this._step3(options).then(function () {
				return _this7._step4(handle);
			}).then(function () {
				return _this7.emit("compile");
			});
		}
	}, {
		key: "flush",
		value: function flush(options, handle) {
			var _this8 = this;

			return this.setup().then(function () {
				return _this8._step2();
			}).then(function () {
				return _this8.compile(lodash.assign({ force: true }, options), handle);
			});
		}
	}, {
		key: "watch",
		value: function watch() {
			var _this9 = this;

			return this.setup().then(function () {
				var watcher = chokidar.watch(_this9.cwd, {
					ignoreInitial: true,
					persistent: true
				});

				var hasChanged = false;
				var change = function change() {
					return hasChanged = true;
				};

				watcher.on("all", function (type, file) {
					var rel = path__default.relative(_this9.cwd, file);
					var isadd = type === "add";
					if ((isadd || type === "unlink" || type === "change") && _this9.test(rel)) {
						_this9.emit("change", type, rel);
						if (isadd) _this9._add_file(rel);
						change();
					}
				});

				return _this9.flush().then(function () {
					var compiling = false;
					var reset = function reset() {
						return compiling = false;
					};
					change = lodash.debounce(function () {
						if (compiling) return change();
						compiling = true;
						_this9.compile().then(reset).catch(function (e) {
							reset();
							_this9.emit("error", e);
						});
					}, 500);

					if (hasChanged) change();
					return watcher;
				});
			});
		}
	}, {
		key: "pack",
		value: function pack(out, options) {
			var _this10 = this;

			if ((typeof out === "undefined" ? "undefined" : babelHelpers.typeof(out)) === "object" && out != null) {
				var _ref = [out, null];
				options = _ref[0];
				out = _ref[1];
			}

			var archive = !out || /\.tar\.gz$|\.tgz$/i.test(out);

			var bundle = undefined;
			var finish = function finish() {
				return bundle && bundle.finalize();
			};

			return read(this.resolve("package.json")).then(function (pkg) {
				if (!out) {
					var name = "superfast-application";
					if (pkg.name) name = pkg.name;
					if (pkg.version) name += " " + pkg.version;
					out = slug(name) + (archive ? ".tar.gz" : "");
				}

				out = _this10.resolve(out);
				var p = [];

				function ship(f, src) {
					if (archive) {
						bundle.entry({ name: 'package/' + f }, src);
					} else {
						(function () {
							var fname = path__default.join(out, f);
							p.push(mkdirp(path__default.dirname(fname)).then(function () {
								return fs.writeFile(fname, src);
							}));
						})();
					}
				}

				return _this10.flush(options, function (outputs) {
					if (archive) {
						bundle = tar.pack();
						bundle.pipe(zlib.createGzip()).pipe(fs.createWriteStream(out));
					}

					var base = [];
					outputs.map(function (f) {
						var b = f.path.split("/").filter(Boolean)[0];
						if (b && !lodash.includes(base, b)) base.push(b);
						ship(f.path, f.source);
					});

					var pkgout = lodash.omit(pkg, "devDependencies", "superfast", "directories", "bin");
					pkgout.scripts = { start: "node .superfast/server.js" };
					pkgout.scripts.clean = "rm -rf " + base.concat("package.json").map(function (b) {
						return JSON.stringify(b);
					}).join(" ");
					ship("package.json", JSON.stringify(pkgout, null, 2));
				}).then(function () {
					return Promise.all(p);
				});
			}).then(function () {
				finish();
				return out;
			}, function (e) {
				finish();
				throw e;
			});
		}
	}, {
		key: "runner",
		value: function runner(options) {
			return new Runner(this, options);
		}
	}, {
		key: "clear",
		value: function clear() {
			var _this11 = this;

			return del(this.buildDir).then(function () {
				_this11.s.setup = false;
			});
		}

		// Step 0: create the superfast directory

	}, {
		key: "_step0",
		value: function _step0() {
			var _this12 = this;

			this.emit("step0");
			return mkdirp(this.buildDir).then(function () {
				if (_this12.s.database) return;
				return new Promise(function (resolve, reject) {
					_this12.s.database = new PouchDB(path__default.join(_this12.buildDir, "cache"), function (err) {
						if (err) reject(err);else resolve();
					});
				});
			});
		}

		// Step 1: load plugins

	}, {
		key: "_step1",
		value: function _step1() {
			var _this13 = this;

			this.emit("step1");
			return fs.readFile(this.resolve("package.json"), {
				encoding: "utf-8"
			}).catch(function (e) {
				if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
			}).then(function (src) {
				var data = src ? JSON.parse(src) : {};
				var plugins = lodash.flatten(["./", data.dependencies ? Object.keys(data.dependencies) : [], data.devDependencies ? Object.keys(data.devDependencies) : []]);

				return _this13.depend(plugins);
			});
		}

		// Step 2: collect files

	}, {
		key: "_step2",
		value: function _step2() {
			var _this14 = this;

			this.emit("step2");

			// scan dir for files and add files
			return this.scan().then(function (files) {
				files.forEach(function (f) {
					return _this14._add_file(f);
				});
			});
		}

		// Step 3: transform files

	}, {
		key: "_step3",
		value: function _step3(options) {
			var _this15 = this;

			this.emit("step3");

			var it = this.s.files.values();
			var removed = [];
			var transformed = [];

			var next = function next() {
				var r = it.next();
				if (r.done) return Promise.resolve();

				var file = r.value;
				return file.transform(options).then(function (res) {
					if (res) transformed.push(file);
					if (file.removed) removed.push(file.path);
					return next();
				});
			};

			return next().then(function () {
				_this15.emit("transform", transformed);
				_this15.emit("removed", removed.map(function (fp) {
					var f = _this15.files.get(fp);
					_this15.files.delete(fp);
					return f;
				}));
			});
		}

		// Step 4: output

	}, {
		key: "_step4",
		value: function _step4(handle) {
			var _this16 = this;

			this.emit("step4");
			if (handle == null) handle = this._write_outputs;

			// get file paths
			var it = this.s.files.keys();
			var filepaths = [],
			    i = undefined;
			while (true) {
				i = it.next();
				if (i.done) break;
				filepaths.push(i.value);
			}

			// sort file paths and get files in order
			filepaths = sortFiles(filepaths);
			var files = filepaths.map(function (fp) {
				return _this16.s.files.get(fp);
			});

			// run outputs
			return Promise.all(lodash.map(this.s.outputs, function (o, name) {
				return confusedAsync(o, _this16, [files, _this16.options[name] || {}]);
			})).then(function (res) {
				res = lodash.flatten(res).filter(function (r) {
					return r && r.path && r.source != null;
				});

				return Promise.resolve(handle.call(_this16, res)).then(function () {
					_this16.emit("output", lodash.map(res, "path"));
				});
			});
		}
	}, {
		key: "_write_outputs",
		value: function _write_outputs(res) {
			var _this17 = this;

			return Promise.all(res.map(function (f) {
				var full = _this17.resolve(".superfast", f.path);
				return mkdirp(path__default.dirname(full)).then(function () {
					return fs.writeFile(full, f.source);
				}).then(function () {
					_this17.emit("output", f.path);
				});
			}));
		}
	}, {
		key: "_add_file",
		value: function _add_file(fpath) {
			var file = this.s.files.get(fpath);
			if (!file) {
				file = new File(this, fpath);
				this.s.files.set(fpath, file);
				this.emit("file", file);
			}
			return file;
		}
	}, {
		key: "cwd",
		get: function get() {
			return this.s.cwd;
		}
	}, {
		key: "production",
		get: function get() {
			return this.s.production;
		}
	}, {
		key: "ignore",
		get: function get() {
			return this.s.ignore;
		}
	}, {
		key: "database",
		get: function get() {
			return this.s.database;
		}
	}, {
		key: "transforms",
		get: function get() {
			return this.s.transforms;
		}
	}, {
		key: "outputs",
		get: function get() {
			return this.s.outputs;
		}
	}, {
		key: "buildDir",
		get: function get() {
			return this.resolve(this.s.build_dir);
		}
	}, {
		key: "files",
		get: function get() {
			return this.s.files;
		}
	}, {
		key: "requires",
		get: function get() {
			return this.s.requires;
		}
	}, {
		key: "watcher",
		get: function get() {
			return this.s.watcher;
		}
	}, {
		key: "hasSetup",
		get: function get() {
			return this.s.setup;
		}
	}], [{
		key: "create",
		value: function create(d, options) {
			options = options || {};
			var compiler = new Compiler(d, options);

			return fs.stat(compiler.cwd).catch(function (e) {
				if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
			}).then(function (stat) {
				if (stat) {
					var err = new Error("Something already exists at the path '" + d + "'.");
					err.human = true;
					throw err;
				}

				return mkdirp(compiler.cwd);
			}).then(function () {
				return latest(["superfast", "superfast-runtime"]);
			}).then(function (r) {
				return Promise.all([cpr(path__default.join(__dirname, "example"), compiler.cwd, {
					overwrite: true
				}), write(path__default.join(compiler.cwd, "package.json"), lodash.assign({
					name: options.name || path__default.basename(compiler.cwd),
					version: "0.0.0",
					scripts: { start: "superfast start" },
					dependencies: { "superfast-runtime": "~" + r["superfast-runtime"] },
					devDependencies: { superfast: "~" + r.superfast }
				}, options.package), null, 2)]);
			}).then(function () {
				return compiler;
			});
		}
	}]);
	return Compiler;
}(events.EventEmitter);

Compiler.defaults = {
	ignore: [".superfast", ".sfignore", "node_modules/", "public/"]
};

exports.Compiler = Compiler;
exports.Runner = Runner;
exports.Source = Source;
exports.File = File;
exports.Module = Module;