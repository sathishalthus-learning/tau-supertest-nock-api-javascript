#!/usr/bin/env node

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var minimist = _interopDefault(require('minimist'));
var lodash = require('lodash');
var util = require('util');
var logUpdate = _interopDefault(require('log-update'));
var elegantSpinner = _interopDefault(require('elegant-spinner'));
var chalk = _interopDefault(require('chalk'));
var child_process = require('child_process');
var path = require('path');
var fs = _interopDefault(require('fs-promise'));
var inquirer = _interopDefault(require('inquirer'));

var spinnerInterval;
var spinnerFrame = function (frame) {
	return function () {
		return chalk.red(frame());
	};
}(elegantSpinner());

var isVerbose = false;
function setVerbose(v) {
	isVerbose = Boolean(v);
}
function verbose() {
	if (isVerbose) log.apply(null, arguments);
}

var isStatic = false;
function setStatic(v) {
	isStatic = Boolean(v);
}

function stopSpinner() {
	if (!spinnerInterval) return;
	clearInterval(spinnerInterval);
	spinnerInterval = null;
}

function log() {
	clear();
	console.log(chalk.dim("=>") + " %s", util.format.apply(null, arguments));
}

function update() {
	stopSpinner();
	if (isStatic) log.apply(null, arguments);else logUpdate(chalk.dim("=>") + " " + util.format.apply(null, arguments));
}

function done() {
	stopSpinner();
	logUpdate.done();
}

function clear() {
	stopSpinner();
	logUpdate.clear();
}

function spinner() {
	if (isStatic) return update.apply(null, arguments);
	stopSpinner();
	var args = arguments;
	spinnerInterval = setInterval(function () {
		logUpdate(spinnerFrame() + "  " + util.format.apply(null, args));
	}, 50);
}

function error(e) {
	if (typeof e === "string") return log(e);
	if (e && e.human) return log(e.toString());
	console.error(e.stack || e);
}

function panic(e) {
	error(e);
	process.exit(1);
}

function shortHelp() {
	console.log(("\n\t$ " + chalk.bold("superfast") + " <command> <args>\n\n\tCommands:\n\t\t" + chalk.green("create") + " <name>      Creates a new Superfast application at <name>.\n\t\t" + chalk.green("start") + "              Starts a local development server in this directory.\n\t\t" + chalk.green("compile") + "            Prepares the Superfast application to be run locally.\n\t\t" + chalk.green("clear") + "              Deletes cached build files for the application.\n\t\t" + chalk.green("pack") + "               Bundles the application into a production-ready package.\n\t\t" + chalk.green("help") + " [command]     Output additional information for a specific command.\n\t\t" + chalk.green("version") + "            Prints the current version of the Superfast CLI.\n\n\tIf no command is provided, Superfast will use " + chalk.green("start") + " and launch a local development server.\n\n\tUse " + chalk.green("help") + " to get more information on Superfast and the CLI.\n").replace(/\t/g, "  "));
}

function help(argv) {
	var args = minimist(argv._);
	var name = undefined;
	if (args._.length) name = args._.shift();

	var p = child_process.spawn("man", ["man/superfast" + (name != null ? "-" + name : "") + ".1"], {
		cwd: __dirname,
		stdio: "inherit"
	});

	p.on("error", panic);
	p.once("exit", function () {
		process.exit(0);
	});
}

function version() {
	var pkg = require("./package.json");
	console.log("%s %s", pkg.name, pkg.version == null ? "dev-build" : "v" + pkg.version);
}

function start(argv, sf) {
	var c = new sf.Compiler(".", argv);
	var runner = c.runner();
	var restarting = false;
	var rebootCount = 0;

	process.stdin.setEncoding("utf-8");
	process.stdin.on("data", function (v) {
		stopSpinner();
		done();

		switch (v.trim()) {
			case "q":
			case "quit":
			case "exit":
				process.exit(0);
				break;

			case "rs":
			case "restart":
				runner.restart();
				break;
		}
	});

	runner.on("start", function (p) {
		if (runner.firstRun) {
			update("Starting application server...");
		}

		var clean = function clean() {
			rebootCount = 0;
			stopSpinner();
			done();
		};

		if (p.stdout.listenerCount("data") === 1) {
			p.stdout._events.data = [p.stdout._events.data];
		}
		p.stdout._events.data.unshift(clean);

		if (p.stderr.listenerCount("data") === 1) {
			p.stderr._events.data = [p.stderr._events.data];
		}
		p.stderr._events.data.unshift(clean);

		p.once("exit", function () {
			p.stdout.removeListener("data", clean);
			p.stderr.removeListener("data", clean);
		});
	});

	runner.on("exit", function (code) {
		if (restarting) {
			restarting = false;
			return;
		}

		var l = [];
		var waiting = false;

		if (code) {
			if (!runner.ready) waiting = true;
			l.push("App exited with an error.");
		} else {
			waiting = true;
			l.push("App exited cleanly.");
		}

		if (waiting) l.push("Waiting for changes before restarting...");
		log(l.join(" "));
	});

	runner.on("ready", function (d) {
		if (!runner.firstRun) {
			rebootCount++;
			var reboot = rebootCount > 1 ? " (x" + rebootCount + ")" : "";
			update("Restarted server" + reboot);
		} else {
			var l = ["Application has started."];
			if (d.port) l.push("View it locally at " + chalk.blue("http://localhost:" + d.port));
			log(l.join(" "));
			log("Type " + chalk.yellow("q<enter>") + " or " + chalk.yellow("Ctrl-C") + " to stop the server.");
		}
	});

	runner.on("restart", function () {
		restarting = true;
	});

	c.on("plugin", function (n) {
		return verbose("plugin : '%s'", n);
	});
	c.on("file", function (f) {
		return verbose("file : '%s'", f.path);
	});

	c.on("step0", function () {
		return spinner("Preparing...");
	});
	c.on("step1", function () {
		return spinner("Loading Plugins...");
	});
	c.on("step2", function () {
		return spinner("Collecting Files...");
	});
	c.on("step3", function () {
		return spinner("Transforming...");
	});
	c.on("step4", function () {
		return spinner("Generating Bundles...");
	});

	c.on("error", function (e) {
		clear();
		if (undefined(e)) {
			process.exit(1);
			return;
		}

		error(e);
		log("App failed to build. Waiting for changes...");
	});

	c.on("compile", function () {
		clear();
		if (!runner.running) runner.start();
	});

	c.watch().catch(panic);
}

function parseArgs (argv, sf, opts) {
	var args = minimist(argv._, opts);
	return lodash.mergeWith({}, sf.Compiler.defaults, lodash.omit(argv, "_"), args, function (a, b) {
		if (lodash.isArray(a) && b != null) return a.concat(b);
	});
}

function create(argv, sf) {
	var args = parseArgs(argv, sf);
	if (!args._.length) {
		return sf.panic("Expecting relative path to create an application at.");
	}

	var d = args._.shift();
	console.log();
	spinner("Creating Superfast application in '" + chalk.blue(d) + "' ...");

	sf.Compiler.create(d, args).then(function (c) {
		var d = path.relative(process.cwd(), c.cwd);
		var l = ["Created Superfast application"];
		if (args.name) l.push(chalk.bold("" + args.name));
		l.push("in '" + chalk.blue(d) + "'");
		log(l.join(" "));
		log("To Use:\n\n" + chalk.green("   $ cd %s\n   $ npm install\n   $ superfast\n"), d);
	}).catch(panic);
}

function clear$1(argv, sf) {
	var args = parseArgs(argv, sf);
	new sf.Compiler(".", args).clear().then(function () {
		log("Removed cached build files.");
		log("Run " + chalk.green("superfast") + " to rebuild and start a local dev server.");
	}).catch(panic);
}

function compile(argv, sf) {
	var args = parseArgs(argv, sf, {
		string: ["ignore"],
		boolean: ["watch"],
		alias: {
			i: "ignore",
			w: "watch"
		}
	});
	var c = new sf.Compiler(".", args);

	c.on("step0", function () {
		return spinner("Preparing...");
	});
	c.on("step1", function () {
		return spinner("Loading Plugins...");
	});
	c.on("step2", function () {
		return spinner("Collecting Files...");
	});
	c.on("step3", function () {
		return spinner("Transforming...");
	});
	c.on("step4", function () {
		return spinner("Generating Bundles...");
	});

	c.on("error", error);
	c.on("compile", function () {
		log("Compiled successfully.");
	});

	if (args.watch) c.watch().catch(error);else c.flush().catch(panic);
}

function pack(argv, sf) {
	var args = parseArgs(argv, sf, {
		boolean: ["yes"],
		string: ["ignore"],
		alias: {
			i: "ignore",
			y: "yes"
		}
	});
	var c = new sf.Compiler(".", lodash.assign({}, args, {
		production: true
	}));

	c.on("step0", function () {
		return spinner("Preparing...");
	});
	c.on("step1", function () {
		return spinner("Loading Plugins...");
	});
	c.on("step2", function () {
		return spinner("Collecting Files...");
	});
	c.on("step3", function () {
		return spinner("Transforming...");
	});
	c.on("step4", function () {
		return spinner("Generating Bundles...");
	});

	var out = args._[0];
	var promise = undefined;

	if (out && !args.yes) {
		out = c.resolve(out);
		promise = fs.stat(out).catch(function (e) {
			if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
		}).then(function (stat) {
			if (!stat) return;

			return new Promise(function (resolve, reject) {
				inquirer.prompt([{
					type: "confirm",
					name: "confirm",
					message: "Something already exists at '" + out + "'. Are you sure you want to overwrite it?",
					default: false
				}], function (r) {
					if (r.confirm) return resolve();

					var err = new Error("Stopping to prevent overwrite.");
					err.human = true;
					reject(err);
				});
			});
		});
	}

	Promise.resolve(promise).then(function () {
		return c.pack(out, args);
	}).then(function (o) {
		log("Packaged successfully to '" + o + "'.");
	}).catch(panic);
}

var superfast = require("./");

var commands = {
	shortHelp: shortHelp, help: help, version: version,
	start: start, create: create, clear: clear$1,
	compile: compile, pack: pack
};

var argv = minimist(process.argv.slice(2), {
	string: ["ignore"],
	boolean: ["help", "version", "verbose", "boring"],
	alias: {
		h: "help", H: "help",
		v: "version", V: "version",
		i: "ignore"
	},
	stopEarly: true
});

// set verbose logging
setVerbose(argv.verbose);
setStatic(argv.boring);

// command aliases
commands.run = commands.start;
commands.rm = commands.remove;
commands.clean = commands.clear;

var cmd = undefined;
if (argv.help) cmd = "shortHelp";else if (argv.version) cmd = "version";else if (!argv._.length) cmd = "start";else cmd = argv._.shift();

if (lodash.has(commands, cmd)) commands[cmd](argv, superfast);else commands.shortHelp();